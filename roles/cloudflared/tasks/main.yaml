---
# 0) Pick a host to run kubectl/k8s calls from (first master)
- name: Pick an apply host (first master)
  tags: [cloudflared]
  run_once: true
  set_fact:
    apply_host: "{{ groups['masters'][0] }}"
    cloudflared_kubeconfig: "{{ cloudflared_kubeconfig | default('/etc/rancher/k3s/k3s.yaml') }}"

# 1) Ensure Python deps for the k8s module on the apply host
- name: Install python kubernetes client on apply host
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  apt:
    update_cache: true
    name:
      - python3-kubernetes
      - python3-yaml
      - python3-requests
    state: present

# 2) All k8s operations in one block with kubeconfig env set
- name: Cloudflared objects (namespace/secret/cm/deploy/netpols)
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  environment:
    K8S_AUTH_KUBECONFIG: "{{ cloudflared_kubeconfig }}"
  block:

    - name: Ensure namespace exists
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ cloudflared_namespace }}"

    # Create/refresh the Secret from runtime token (kept out of git)
    - name: Create or update cloudflared token Secret (only if provided)
      when: cloudflared_tunnel_token is defined
      no_log: true
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: cloudflared-token
            namespace: "{{ cloudflared_namespace }}"
          stringData:
            TUNNEL_TOKEN: "{{ cloudflared_tunnel_token }}"

    # Assert Secret exists regardless (created above or manually)
    - name: Assert token Secret exists
      k8s_info:
        api_version: v1
        kind: Secret
        name: cloudflared-token
        namespace: "{{ cloudflared_namespace }}"
      register: token_info
      failed_when: (token_info.resources | length) == 0
      changed_when: false

    - name: Apply ConfigMap (wildcard â†’ Traefik)
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: cloudflared-config
            namespace: "{{ cloudflared_namespace }}"
          data:
            config.yaml: |
              ingress:
                - hostname: "*.{{ cloudflare_domain }}"
                  service: {{ traefik_service_url }}
                - service: http_status:404
              metrics: 0.0.0.0:2000
              no-autoupdate: true

    - name: Apply Deployment
      k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cloudflared
            namespace: "{{ cloudflared_namespace }}"
            labels: { app: cloudflared }
          spec:
            replicas: "{{ cloudflared_replicas }}"
            selector: { matchLabels: { app: cloudflared } }
            template:
              metadata:
                labels: { app: cloudflared }
              spec:
                nodeSelector: "{{ cloudflared_node_selector | default(omit) }}"
                containers:
                  - name: cloudflared
                    image: "{{ cloudflared_image }}"
                    args: ["tunnel","--no-autoupdate","run"]
                    env:
                      - name: TUNNEL_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: cloudflared-token
                            key: TUNNEL_TOKEN
                    ports:
                      - name: metrics
                        containerPort: 2000
                        protocol: TCP
                    readinessProbe:
                      httpGet: { path: /ready, port: 2000 }
                      periodSeconds: 10
                    livenessProbe:
                      httpGet: { path: /metrics, port: 2000 }
                      periodSeconds: 30
                    volumeMounts:
                      - name: cfg
                        mountPath: /etc/cloudflared/config
                volumes:
                  - name: cfg
                    configMap:
                      name: cloudflared-config

    - name: Apply NetworkPolicy (egress to DNS + Traefik)
      k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: cloudflared-egress
            namespace: "{{ cloudflared_namespace }}"
          spec:
            podSelector: { matchLabels: { app: cloudflared } }
            policyTypes: ["Egress"]
            egress:
              - to:
                  - namespaceSelector:
                      matchLabels:
                        kubernetes.io/metadata.name: kube-system
                    podSelector:
                      matchLabels:
                        k8s-app: kube-dns
                ports:
                  - { protocol: UDP, port: 53 }
                  - { protocol: TCP, port: 53 }
              - to:
                  - namespaceSelector:
                      matchLabels:
                        kubernetes.io/metadata.name: kube-system
                    podSelector:
                      matchLabels:
                        app.kubernetes.io/name: traefik
                ports:
                  - { protocol: TCP, port: 80 }

    - name: Apply NetworkPolicy (deny ingress to cloudflared pods)
      k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: cloudflared-ingress-deny
            namespace: "{{ cloudflared_namespace }}"
          spec:
            podSelector: { matchLabels: { app: cloudflared } }
            policyTypes: ["Ingress"]
