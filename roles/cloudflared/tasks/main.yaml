---
# Cloudflared: namespace, secret, config, deployment, netpols

# 0) Pick a host to run k8s calls from (first master) and set kubeconfig path
- name: Pick an apply host (first master)
  tags: [cloudflared]
  run_once: true
  set_fact:
    apply_host: "{{ groups['masters'][0] }}"
    cloudflared_kubeconfig: "{{ cloudflared_kubeconfig | default('/etc/rancher/k3s/k3s.yaml') }}"

# 1) Ensure Python deps for the Ansible k8s module on the apply host
- name: Install python kubernetes client on apply host
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  apt:
    update_cache: true
    name:
      - python3-kubernetes
      - python3-yaml
      - python3-requests
    state: present

# (Optional) clear a stuck progressDeadlineExceeded
- name: (Optional) Delete existing cloudflared Deployment to clear stuck rollout
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  environment:
    K8S_AUTH_KUBECONFIG: "{{ cloudflared_kubeconfig }}"
  when: cloudflared_force_recreate | default(false)
  k8s:
    state: absent
    kind: Deployment
    name: cloudflared
    namespace: "{{ cloudflared_namespace }}"

# 2) All Kubernetes operations with correct kubeconfig
- name: Cloudflared objects (namespace/secret/config/deploy/netpols)
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  environment:
    K8S_AUTH_KUBECONFIG: "{{ cloudflared_kubeconfig }}"
  block:

    # Namespace
    - name: Ensure namespace exists
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ cloudflared_namespace }}"

    # Secret (created/updated only if you pass a token at runtime)
    - name: Create or update cloudflared token Secret (only if provided)
      when: cloudflared_tunnel_token is defined
      no_log: true
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: cloudflared-token
            namespace: "{{ cloudflared_namespace }}"
          stringData:
            TUNNEL_TOKEN: "{{ cloudflared_tunnel_token }}"

    # Assert Secret exists (either created above or pre-created manually)
    - name: Assert token Secret exists
      k8s_info:
        api_version: v1
        kind: Secret
        name: cloudflared-token
        namespace: "{{ cloudflared_namespace }}"
      register: token_info
      failed_when: (token_info.resources | length) == 0
      changed_when: false

    # ConfigMap: wildcard to Traefik, metrics, IPv4/QUIC toggles
    - name: Apply ConfigMap (wildcard → Traefik)
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: cloudflared-config
            namespace: "{{ cloudflared_namespace }}"
          data:
            config.yaml: |
              ingress:
                - hostname: "*.{{ cloudflare_domain }}"
                  service: {{ traefik_service_url }}
                - service: http_status:404
              metrics: 0.0.0.0:2000
              no-autoupdate: true
              edge-ip-version: "{{ (cloudflared_force_ipv4 | default(true)) | ternary('4', 'auto') }}"
              {% if cloudflared_disable_quic | default(false) %}no-quic: true{% endif %}

    # Deployment (prefer IPv4; optionally disable QUIC via args too)
    - name: Apply Deployment
      k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cloudflared
            namespace: "{{ cloudflared_namespace }}"
            labels: { app: cloudflared }
          spec:
            replicas: "{{ cloudflared_replicas }}"
            selector: { matchLabels: { app: cloudflared } }
            template:
              metadata:
                labels: { app: cloudflared }
              spec:
                nodeSelector: "{{ cloudflared_node_selector | default(omit) }}"
                terminationGracePeriodSeconds: 10
                containers:
                  - name: cloudflared
                    image: "{{ cloudflared_image }}"
                    imagePullPolicy: IfNotPresent
                    args:
                      - "tunnel"
                      - "--no-autoupdate"
                      - "run"
                    env:
                      - name: TUNNEL_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: cloudflared-token
                            key: TUNNEL_TOKEN
                    ports:
                      - name: metrics
                        containerPort: 2000
                        protocol: TCP
                    readinessProbe:
                      httpGet:
                        path: /ready
                        port: 2000
                      periodSeconds: 10
                    livenessProbe:
                      httpGet:
                        path: /metrics
                        port: 2000
                      periodSeconds: 30
                    volumeMounts:
                      - name: cfg
                        mountPath: /etc/cloudflared/config
                volumes:
                  - name: cfg
                    configMap:
                      name: cloudflared-config

    # NetworkPolicy: allow egress to kube-dns, Traefik, and Cloudflare edge
    - name: Apply NetworkPolicy (egress to DNS + Traefik + Internet)
      k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: cloudflared-egress
            namespace: "{{ cloudflared_namespace }}"
          spec:
            podSelector: { matchLabels: { app: cloudflared } }
            policyTypes: ["Egress"]
            egress:
              # kube-dns (name resolution) — allow to pods in kube-system on port 53
              - to:
                  - namespaceSelector:
                      matchLabels:
                        kubernetes.io/metadata.name: kube-system
                ports:
                  - { protocol: UDP, port: 53 }
                  - { protocol: TCP, port: 53 }
              # Traefik (ClusterIP:80) inside the cluster
              - to:
                  - namespaceSelector:
                      matchLabels:
                        kubernetes.io/metadata.name: kube-system
                    podSelector:
                      matchLabels:
                        app.kubernetes.io/name: traefik
                ports:
                  - { protocol: TCP, port: 80 }
              # Cloudflare edge on the internet (QUIC + HTTPS)
              - to:
                  - ipBlock: { cidr: 0.0.0.0/0 }
                ports:
                  - { protocol: UDP, port: 7844 }  # QUIC
                  - { protocol: TCP, port: 443 }   # HTTP/2 fallback

    # NetworkPolicy: deny all ingress to cloudflared pods (client-only)
    - name: Apply NetworkPolicy (deny ingress to cloudflared pods)
      k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: cloudflared-ingress-deny
            namespace: "{{ cloudflared_namespace }}"
          spec:
            podSelector: { matchLabels: { app: cloudflared } }
            policyTypes: ["Ingress"]
            ingress: []

# 3) Wait for rollout and show status (uses k3s' kubectl directly)
- name: Wait for cloudflared rollout
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} rollout status deploy/cloudflared --timeout=180s
  changed_when: false

- name: Show cloudflared pods
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} get pods -o wide
  changed_when: false
