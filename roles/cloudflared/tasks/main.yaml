---
# Cloudflared: namespace, secret, config, deployment, netpols

# 0) Pick a host to run k8s calls from (first master) and set kubeconfig path
- name: Pick an apply host (first master)
  tags: [cloudflared]
  run_once: true
  set_fact:
    apply_host: "{{ groups['masters'][0] }}"
    cloudflared_kubeconfig: "{{ cloudflared_kubeconfig | default('/etc/rancher/k3s/k3s.yaml') }}"

# 1) Ensure Python deps for the Ansible k8s module on the apply host
- name: Install python kubernetes client on apply host
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  apt:
    update_cache: true
    name:
      - python3-kubernetes
      - python3-yaml
      - python3-requests
    state: present

# Optional: clear a stuck rollout if requested
- name: (Optional) Delete existing cloudflared Deployment to clear stuck rollout
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  environment:
    K8S_AUTH_KUBECONFIG: "{{ cloudflared_kubeconfig }}"
  when: cloudflared_force_recreate | default(false)
  k8s:
    state: absent
    kind: Deployment
    name: cloudflared
    namespace: "{{ cloudflared_namespace }}"

# 2) All Kubernetes operations with correct kubeconfig
- name: Cloudflared objects (namespace/secret/config/deploy/netpols)
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  environment:
    K8S_AUTH_KUBECONFIG: "{{ cloudflared_kubeconfig }}"
  block:

    # Namespace
    - name: Ensure namespace exists
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ cloudflared_namespace }}"

    # Secret (created/updated only if you pass a token at runtime or via vault)
    - name: Create or update cloudflared token Secret (only if provided)
      when: cloudflared_tunnel_token is defined
      no_log: true
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: cloudflared-token
            namespace: "{{ cloudflared_namespace }}"
          stringData:
            TUNNEL_TOKEN: "{{ cloudflared_tunnel_token }}"

    # Assert Secret exists (either created above or pre-created manually)
    - name: Assert token Secret exists
      k8s_info:
        api_version: v1
        kind: Secret
        name: cloudflared-token
        namespace: "{{ cloudflared_namespace }}"
      register: token_info
      failed_when: (token_info.resources | length) == 0
      changed_when: false

    # ConfigMap: wildcard to Traefik Service on 443 (Service DNS), HTTP/2 transport hints
    - name: Apply ConfigMap (wildcard â†’ Traefik Service on 443)
      k8s:
        state: present
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: cloudflared-config
            namespace: "{{ cloudflared_namespace }}"
          data:
            config.yaml: |
              ingress:
                - hostname: "*.{{ cloudflare_domain }}"
                  service: https://traefik.kube-system.svc.cluster.local:443
                  originRequest:
                    noTLSVerify: true
                - service: http_status:404
              metrics: 0.0.0.0:2000
              edge-ip-version: "4"
              no-autoupdate: true

    # Deployment: run cloudflared with http2 transport and config file above
    - name: Apply Deployment
      k8s:
        state: present
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: cloudflared
            namespace: "{{ cloudflared_namespace }}"
            labels: { app: cloudflared }
          spec:
            replicas: {{ cloudflared_replicas | default(2) }}
            selector: { matchLabels: { app: cloudflared } }
            template:
              metadata:
                labels: { app: cloudflared }
              spec:
                nodeSelector: "{{ cloudflared_node_selector | default(omit) }}"
                terminationGracePeriodSeconds: 10
                containers:
                  - name: cloudflared
                    image: "{{ cloudflared_image | default('cloudflare/cloudflared:2024.8.3') }}"
                    imagePullPolicy: IfNotPresent
                    args:
                      - "tunnel"
                      - "--no-autoupdate"
                      - "--protocol"
                      - "{{ cloudflared_protocol | default('http2') }}"
                      - "--config"
                      - "/etc/cloudflared/config/config.yaml"
                      - "run"
                    env:
                      - name: TUNNEL_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: cloudflared-token
                            key: TUNNEL_TOKEN
                      - name: TUNNEL_TRANSPORT_PROTOCOL
                        value: "{{ cloudflared_protocol | default('http2') }}"
                    ports:
                      - name: metrics
                        containerPort: 2000
                        protocol: TCP
                    readinessProbe:
                      httpGet:
                        path: /ready
                        port: 2000
                      periodSeconds: 10
                    livenessProbe:
                      httpGet:
                        path: /metrics
                        port: 2000
                      periodSeconds: 30
                    volumeMounts:
                      - name: cfg
                        mountPath: /etc/cloudflared/config
                volumes:
                  - name: cfg
                    configMap:
                      name: cloudflared-config

    # NetworkPolicy: allow egress to DNS, cluster ranges, and Cloudflare edge
    - name: Apply NetworkPolicy (egress to DNS + ClusterIP/Pod + Internet)
      when: (cloudflared_enable_networkpolicy | default(true)) | bool
      k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: cloudflared-egress
            namespace: "{{ cloudflared_namespace }}"
          spec:
            podSelector: { matchLabels: { app: cloudflared } }
            policyTypes: ["Egress"]
            egress:
              # kube-dns (CoreDNS) in kube-system
              - to:
                  - namespaceSelector:
                      matchLabels:
                        kubernetes.io/metadata.name: kube-system
                ports:
                  - { protocol: UDP, port: 53 }
                  - { protocol: TCP, port: 53 }
              # Service IP range (ClusterIP) and Pod IP range for Traefik
              - to: [ { ipBlock: { cidr: 10.43.0.0/16 } } ]  # Services
                ports: [ { protocol: TCP, port: 443 }, { protocol: TCP, port: 80 } ]
              - to: [ { ipBlock: { cidr: 10.42.0.0/16 } } ]  # Pods (Traefik 8443/8000 if ever needed)
                ports: [ { protocol: TCP, port: 8443 }, { protocol: TCP, port: 8000 } ]
              # Cloudflare edge (QUIC+HTTPS); QUIC may fail sometimes, HTTP/2 works fine
              - to: [ { ipBlock: { cidr: 0.0.0.0/0 } } ]
                ports: [ { protocol: TCP, port: 443 }, { protocol: UDP, port: 7844 } ]

    # NetworkPolicy: deny all ingress to cloudflared pods (client-only)
    - name: Apply NetworkPolicy (deny ingress to cloudflared pods)
      when: (cloudflared_enable_networkpolicy | default(true)) | bool
      k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: cloudflared-ingress-deny
            namespace: "{{ cloudflared_namespace }}"
          spec:
            podSelector: { matchLabels: { app: cloudflared } }
            policyTypes: ["Ingress"]
            ingress: []

# 3) Wait for rollout and show status (uses k3s' kubectl directly)
- name: Wait for cloudflared rollout
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} rollout status deploy/cloudflared --timeout=240s
  changed_when: false

- name: Show cloudflared pods
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} get pods -o wide
  changed_when: false
