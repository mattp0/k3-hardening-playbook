---
# Run kubectl commands from a single master with built-in k3s kubeconfig
- name: Pick an apply host (first master)
  tags: [cloudflared]
  run_once: true
  set_fact:
    apply_host: "{{ groups['masters'][0] }}"

- name: Ensure namespace exists
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl apply -f - 
  args:
    stdin: |
      apiVersion: v1
      kind: Namespace
      metadata:
        name: {{ cloudflared_namespace }}

# 1) Render a Secret manifest with stringData (not saved to git)
- name: Write cloudflared Secret manifest (from runtime token)
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  when:
    - enable_cloudflare_tunnel | default(false)
    - cloudflared_tunnel_token is defined
  copy:
    dest: /tmp/cloudflared-secret.yaml
    mode: "0600"
    content: |
      apiVersion: v1
      kind: Secret
      type: Opaque
      metadata:
        name: cloudflared-token
        namespace: {{ cloudflared_namespace }}
      stringData:
        TUNNEL_TOKEN: "{{ cloudflared_tunnel_token }}"
  no_log: true

# 2) Apply it
- name: Apply cloudflared Secret
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  when:
    - enable_cloudflare_tunnel | default(false)
    - cloudflared_tunnel_token is defined
  command: k3s kubectl apply -f /tmp/cloudflared-secret.yaml
  changed_when: false
  no_log: true

# (Keep your existing assert so the run fails if no Secret exists and no token provided)
- name: Assert token Secret exists
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} get secret cloudflared-token
  register: token_chk
  failed_when: token_chk.rc != 0
  changed_when: false


# Write ConfigMap (wildcard â†’ Traefik)
- name: Render cloudflared config to the master
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  copy:
    dest: /tmp/cloudflared-config.yaml
    mode: "0644"
    content: |
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: cloudflared-config
        namespace: {{ cloudflared_namespace }}
      data:
        config.yaml: |
          ingress:
            - hostname: "*.{{ cloudflare_domain }}"
              service: {{ traefik_service_url }}
            - service: http_status:404
          metrics: 0.0.0.0:2000
          no-autoupdate: true

- name: Apply ConfigMap
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl apply -f /tmp/cloudflared-config.yaml
  changed_when: false

# Deployment
- name: Render cloudflared deployment to the master
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  copy:
    dest: /tmp/cloudflared-deploy.yaml
    mode: "0644"
    content: |
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: cloudflared
        namespace: {{ cloudflared_namespace }}
        labels: { app: cloudflared }
      spec:
        replicas: {{ cloudflared_replicas }}
        selector: { matchLabels: { app: cloudflared } }
        template:
          metadata:
            labels: { app: cloudflared }
          spec:
            {{- if cloudflared_node_selector and cloudflared_node_selector | length }}
            nodeSelector:
            {%- for k, v in cloudflared_node_selector.items() %}
              {{ k }}: "{{ v }}"
            {%- endfor %}
            {{- endif }}
            containers:
            - name: cloudflared
              image: {{ cloudflared_image }}
              args: ["tunnel", "--no-autoupdate", "run"]
              env:
              - name: TUNNEL_TOKEN
                valueFrom:
                  secretKeyRef:
                    name: cloudflared-token
                    key: TUNNEL_TOKEN
              ports:
              - name: metrics
                containerPort: 2000
                protocol: TCP
              readinessProbe:
                httpGet: { path: /ready, port: 2000 }
                periodSeconds: 10
              livenessProbe:
                httpGet: { path: /metrics, port: 2000 }
                periodSeconds: 30
              volumeMounts:
              - name: cfg
                mountPath: /etc/cloudflared/config
            volumes:
            - name: cfg
              configMap:
                name: cloudflared-config

- name: Apply deployment
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl apply -f /tmp/cloudflared-deploy.yaml
  changed_when: false

# NetworkPolicies (egress only to DNS + Traefik, deny ingress)
- name: Render netpols
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  copy:
    dest: /tmp/cloudflared-netpol.yaml
    mode: "0644"
    content: |
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        name: cloudflared-egress
        namespace: {{ cloudflared_namespace }}
      spec:
        podSelector: { matchLabels: { app: cloudflared } }
        policyTypes: ["Egress"]
        egress:
          - to:
              - namespaceSelector:
                  matchLabels:
                    kubernetes.io/metadata.name: kube-system
                podSelector:
                  matchLabels:
                    k8s-app: kube-dns
            ports:
              - { protocol: UDP, port: 53 }
              - { protocol: TCP, port: 53 }
          - to:
              - namespaceSelector:
                  matchLabels:
                    kubernetes.io/metadata.name: kube-system
                podSelector:
                  matchLabels:
                    app.kubernetes.io/name: traefik
            ports:
              - { protocol: TCP, port: 80 }
      ---
      apiVersion: networking.k8s.io/v1
      kind: NetworkPolicy
      metadata:
        name: cloudflared-ingress-deny
        namespace: {{ cloudflared_namespace }}
      spec:
        podSelector: { matchLabels: { app: cloudflared } }
        policyTypes: ["Ingress"]
        ingress: []

- name: Apply netpols
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl apply -f /tmp/cloudflared-netpol.yaml
  changed_when: false

- name: Wait for rollout
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} rollout status deploy/cloudflared --timeout=180s
  changed_when: false

- name: Show pod status
  tags: [cloudflared]
  run_once: true
  delegate_to: "{{ apply_host }}"
  become: true
  command: k3s kubectl -n {{ cloudflared_namespace }} get pods -o wide
  changed_when: false
